<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_05) on Tue Sep 04 19:39:26 CEST 2012 -->
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<title>Overview (json-schema-validator 1.1.1 API)</title>
<meta name="date" content="2012-09-04">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Overview (json-schema-validator 1.1.1 API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">json-schema-validator 1.1.1 API</h1>
</div>
<div class="header">
<div class="subTitle">
<div class="block">A JSON Schema validator implementation in Java which aims for correctness and
performance, in that order</div>
</div>
<p>See: <a href="#overview_description">Description</a></p>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Packages table, listing packages, and an explanation">
<caption><span>Packages</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Package</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="org/eel/kitchen/jsonschema/bundle/package-summary.html">org.eel.kitchen.jsonschema.bundle</a></td>
<td class="colLast">
<div class="block">Schema keywords and keyword bundles</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="org/eel/kitchen/jsonschema/format/package-summary.html">org.eel.kitchen.jsonschema.format</a></td>
<td class="colLast">
<div class="block">Format specifier classes</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="org/eel/kitchen/jsonschema/keyword/package-summary.html">org.eel.kitchen.jsonschema.keyword</a></td>
<td class="colLast">
<div class="block">Schema validation core elements: keyword validators</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="org/eel/kitchen/jsonschema/main/package-summary.html">org.eel.kitchen.jsonschema.main</a></td>
<td class="colLast">
<div class="block">Main schema validation API</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="org/eel/kitchen/jsonschema/ref/package-summary.html">org.eel.kitchen.jsonschema.ref</a></td>
<td class="colLast">
<div class="block">JSON Reference related classes</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="org/eel/kitchen/jsonschema/report/package-summary.html">org.eel.kitchen.jsonschema.report</a></td>
<td class="colLast">
<div class="block">Validation reports and messages</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="org/eel/kitchen/jsonschema/syntax/package-summary.html">org.eel.kitchen.jsonschema.syntax</a></td>
<td class="colLast">
<div class="block">Schema syntax validation package</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="org/eel/kitchen/jsonschema/uri/package-summary.html">org.eel.kitchen.jsonschema.uri</a></td>
<td class="colLast">
<div class="block">Classes to handle downloading of JSON documents</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="org/eel/kitchen/jsonschema/util/package-summary.html">org.eel.kitchen.jsonschema.util</a></td>
<td class="colLast">
<div class="block">Various utility classes</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="org/eel/kitchen/jsonschema/validator/package-summary.html">org.eel.kitchen.jsonschema.validator</a></td>
<td class="colLast">
<div class="block">Core validation process</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="footer"><a name="overview_description">
<!--   -->
</a>
<div class="subTitle">
<div class="block">A JSON Schema validator implementation in Java which aims for correctness and
performance, in that order

<h1>What this is</h1>

<h2>Motivation</h2>

<p>This implementation is meant to be purely server-side if Java is your
language of choice. You may, <b>or may not</b>, use it in your Java Web
application; this library has no dependencies on anything Web-related.</p>

<h2>Strong points</h2>

<p>This library has three main characteristics which make it stand apart from
other existing implementations. While some other libraries also bear one or two
of the below characteristics, none can pretend to all three of them:</p>

<ul>
    <li><b>Correctness</b>&nbsp;It is currently the only library in existence to
    accurately validate numeric JSON instances of arbitraty length/precision; it
    also accurately uses an ECMA 262 regular expression engine to validate
    patterns (JavaScript libraries all do, of course, but then the JavaScript
    standard requires it);</li>
    <li><b>Raw speed</b>&nbsp;Downloaded schemas are cached, syntax validation
    results are cached, validators are cached. All of them can therefore be
    reused each time you have to validate data against a same schema.</li>
    <li><b>Fully thread safe</b>&nbsp;All schema object instances are immutable,
    therefore thread safe. You can use the same instance in several threads in
    parallel and validate as much data as you want.</li>
</ul>

<h1>Sample usage</h1>

<h2>Create a <a href="org/eel/kitchen/jsonschema/main/JsonSchemaFactory.html" title="class in org.eel.kitchen.jsonschema.main"><code>JsonSchemaFactory</code></a></h2>

<p>You have two choices: create a factory with default settings, or use a <a href="org/eel/kitchen/jsonschema/main/JsonSchemaFactory.Builder.html" title="class in org.eel.kitchen.jsonschema.main"><code>JsonSchemaFactory.Builder</code></a> if you want to
customize your factory.</p>

<p>To build a factory with default settings, use:</p>

<pre>
    final JsonSchemaFactory factory = JsonSchemaFactory.defaultFactory();
</pre>

<p>You can customize your factory in many ways:</p>

<ul>
    <li>registering/unregistering keywords;</li>
    <li>registering/unregistering URI schemes;</li>
    <li>adding a URI namespace, and URI redirections;</li>
    <li>setting validation features.</li>
</ul>

<p>For this, the way to build a factory differs:</p>

<pre>
    final JsonSchemaFactory = new JsonSchemaFactory.Builder()
        .xxx().xxx().build();
</pre>

<p>where <code>xxx</code> is a method depending on the customization you wish to
make.</p>

<p>See below, and refer to the javadoc for more details.</p>

<h2>Register/create a schema</h2>

<p>The class for this is <a href="org/eel/kitchen/jsonschema/main/JsonSchema.html" title="class in org.eel.kitchen.jsonschema.main"><code>JsonSchema</code></a>.</p>

<p>You have two choices:</p>

<ul>
    <li>get an instance directly from a URI (in this case, ensure that the URI
    scheme is supported beforehand, see below);</li>
    <li>load your schema as a <a href="http://fasterxml.github.com/jackson-databind/javadoc/2.0.5/com/fasterxml/jackson/databind/JsonNode.html?is-external=true" title="class or interface in com.fasterxml.jackson.databind"><code>JsonNode</code></a>,
    and create a schema instance from that JsonNode.</li>
</ul>

<p>The sample code below shows how to create a <a href="org/eel/kitchen/jsonschema/main/JsonSchema.html" title="class in org.eel.kitchen.jsonschema.main"><code>JsonSchema</code></a> from the v3 schema draft, bundled in
this library:</p>

<pre>
    final JsonSchema schema = factory.fromURI("resources:/schema-draftv3.json");
</pre>

<h2>Validate your data</h2>

<p>Currently, you must load the data to be validated as a <a href="http://fasterxml.github.com/jackson-databind/javadoc/2.0.5/com/fasterxml/jackson/databind/JsonNode.html?is-external=true" title="class or interface in com.fasterxml.jackson.databind"><code>JsonNode</code></a>. Have a look at the <a href="org/eel/kitchen/jsonschema/util/JsonLoader.html" title="class in org.eel.kitchen.jsonschema.util"><code>JsonLoader</code></a> class, which provides ways of
loading JSON from various sources.</p>

<p>One <a href="org/eel/kitchen/jsonschema/main/JsonSchema.html" title="class in org.eel.kitchen.jsonschema.main"><code>JsonSchema</code></a> instance may validate
as many JSON documents as you want, in parallel: this class is inherently thread
safe. Sample code:</p>

<pre>
    // Here, instance is the data to validate

    final ValidationReport report = schema.validate(instance);

    // Validation is a success if the report is empty: test it as follows

    System.out.printf("Validation %s\n", report.isSuccess() ? "succeeded"
        : "failed");
</pre>

<h2>Using validation messages</h2>

<p>In the event of a failure, you have the option to retrieve the whole set of
validation messages as JSON:</p>

<ul>
    <li>either a JSON object, with paths into the instance as keys, and an
    array of validation messages for that path as values;</li>
    <li>or as a JSON array, whose members are JSON objects containing the
    message contents plus the path.</li>
</ul>

<p>Paths are represented as <a
href="http://tools.ietf.org/id/draft-ietf-appsawg-json-pointer-03.txt">JSON
Pointers</a>.</p>

<p>Another option is to retrieve a list of simple strings: this list will
contain as much information as the above method, though in a much less
exploitable format -- it is more suited for logging purposes, though.</p>

<p>See <a href="org/eel/kitchen/jsonschema/report/ValidationReport.html" title="class in org.eel.kitchen.jsonschema.report"><code>ValidationReport</code></a> and <a href="org/eel/kitchen/jsonschema/report/ValidationMessage.html" title="class in org.eel.kitchen.jsonschema.report"><code>ValidationMessage</code></a> for details.</p>

<h1>Customizing your schema factory</h1>

<p>First note that all customization is achieved via the associated builder:
once a factory is created, it cannot be modified.</p>

<h2>Adding a default URI namespace</h2>

<p>When resolving JSON References, relative URIs may be encountered. In this
case, they should be resolved against the parent schema's location. But it can
happen that the parent schema's location is empty: in this case, the URI will
not resolve. As a matter of fact, the class in charge of getting a JSON document
from an URI, <a href="org/eel/kitchen/jsonschema/uri/URIManager.html" title="class in org.eel.kitchen.jsonschema.uri"><code>URIManager</code></a>, will refuse to
get content from a relative URI.</p>

<p>To work around this problem, you have the ability to set a default namespace:
relative URIs will then be resolved with regards to that namespace. This can be
useful if, for instance, you perform offline validation.</p>

<p>One possible scenario is to have a set of schemas on the local filesystem,
and schemas refer to one another in a relative way. You can do:</p>

<pre>
    // Note the ending /, it is necessary!
    final JsonSchemaFactory factory = new JsonSchemaFactory.Builder()
        .setNamespace("file:///path/to/base/directory/").build();

    // Create a schema from a file named mySchema.json which is in the above
    // directory:
    final JsonSchema schema = factory.fromURI("mySchema.json");
</pre>

<h2>Adding URI redirections</h2>

<p>If you use schemas which reference other schemas via URIs you know will not
be reachable at runtime, this mechanism allows you to tell the validation
process to redirect all references to these URIs to other URIs you know you can
resolve locally. For instance:</p>

<pre>
    // Reference to external schema, and the local version of it
    final String from = "http://external.site/the/schema.json";
    final String to = "file:///path/to/local-copy.json";

    final JsonSchemaFactory factory = new JsonSchemaFactory.Builder()
        .addRedirection(from, to).build();
</pre>

<p>You can, of course, add more than one redirection.</p>

<p>Note, this only works for fully resolvable URIs (ie, URIs referring to actual
content), not directories.</p>

<h2>Registering/unregistering keywords</h2>

<p>For this, you need three elements:</p>

<ul>
    <li>the name for your new keyword;</li>
    <li>a <a href="org/eel/kitchen/jsonschema/syntax/SyntaxChecker.html" title="interface in org.eel.kitchen.jsonschema.syntax"><code>SyntaxChecker</code></a> instance;</li>
    <li>a <a href="org/eel/kitchen/jsonschema/keyword/KeywordValidator.html" title="class in org.eel.kitchen.jsonschema.keyword"><code>KeywordValidator</code></a>.</li>
</ul>

<p>The keyword validator needs to have one constructor taking a JsonNode as an
argument (<b>keyword validators are built by reflection</b> -- this is what
allows them to be cached). You can then register the keyword to your factory
like this:</p>

<pre>
    final Keyword myKeyword = Keyword.Builder.forName("mykeyword")
        .withSyntaxChecker(mySyntaxChecker)
        .withValidatorClass(MyKeywordValidator.class)
        .build();

    final JsonSchemaFactory.Builder builder = new JsonSchemaFactory.Builder();

    // Register your own keyword, and unregister "format"
    builder.registerKeyword(myKeyword).unregisterKeyword("format");

    // Build the factory
    final JsonSchemaFactory factory = builder.build();
</pre>

<p>For further information, see <a href="org/eel/kitchen/jsonschema/syntax/package-summary.html"><code>org.eel.kitchen.jsonschema.syntax</code></a> and
<a href="org/eel/kitchen/jsonschema/keyword/package-summary.html"><code>org.eel.kitchen.jsonschema.keyword</code></a>.</p>

<h2>Registering/unregistering format specifiers</h2>

<p>The draft defines the <tt>format</tt> keyword in section 5.23. It explicitly
mentions that custom format specifiers MAY be created. You can do this with this
implementation.</p>

<p>The principle is the same as for keywords. Note also that this library only
supports a subset of all specifiers defined by the draft: other specifiers are
now in a separate package.</p>

<p>See <a href="org/eel/kitchen/jsonschema/format/package-summary.html"><code>org.eel.kitchen.jsonschema.format</code></a> for more information.</p>

<h2>Registering/unregistering URI schemes</h2>

<p>A JSON Reference is a URI, and this URI can be of any scheme. This
implementation has native support for the following schemes, which are
guaranteed to be implemented by any Java implementation: <tt>http</tt>,
<tt>ftp</tt>, <tt>file</tt> and <tt>jar</tt>. While <tt>https</tt> is also
guaranteed to be implemented, this implementation chooses not to offer support
for it, because of certificate matters, which can be quite cumbersome.</p>

<p>You can, if you wish, either override the existing supported schemes, or add
support for a new scheme, by implementing <a href="org/eel/kitchen/jsonschema/uri/URIDownloader.html" title="interface in org.eel.kitchen.jsonschema.uri"><code>URIDownloader</code></a> and register it in your factory,
like this:</p>

<pre>
    final URIDownloader myDownloader = new URIDownloader()
    {
        &#64;Override
        public InputStream fetch(final URI source)
            throws IOException
        {
            // your code here
        }
    };

    // Example of registering a new scheme and unregistering another one
    final JsonSchemaFactory factory = new JsonSchemaFactory.Builder()
        .registerScheme("myscheme", myDownloader)
        .unregisterScheme("ftp")
        .build();
</pre>

<h2>Setting validation features</h2>

<p>This is done using the <tt>.setFeature()</tt> method of a schema factory
builder. For now, the only existing feature is called <a href="org/eel/kitchen/jsonschema/main/ValidationFeature.html#STRICT_RFC_CONFORMANCE"><code>ValidationFeature.STRICT_RFC_CONFORMANCE</code></a>. It is
used by the <tt>host-name</tt> and <tt>email</tt> format specifiers since, by
default, they require that both hostnames and emails have a domain part -- but
RFCs do not require this. This brings those two validators in conformance with
their respective RFCs.</p>

<h1>The core stuff: the validation process</h1>

<p>The validation process is a three step process:</p>

<ul>
    <li><tt>$ref</tt> resolution;</li>
    <li>schema syntax validation;</li>
    <li>instance validation (ie, validate your data).</li>
</ul>

<p>The core package for the validation process is <a href="org/eel/kitchen/jsonschema/validator/package-summary.html"><code>org.eel.kitchen.jsonschema.validator</code></a>, and in particular <a href="org/eel/kitchen/jsonschema/validator/JsonValidatorCache.html" title="class in org.eel.kitchen.jsonschema.validator"><code>JsonValidatorCache</code></a>. This class is
instantiated by a schema factory and uses a <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/LoadingCache.html?is-external=true" title="class or interface in com.google.common.cache"><code>LoadingCache</code></a> to store already computed validators.</p>

<h2><tt>$ref</tt> resolution</h2>

<p>This is a critically important part of the validation process. You may
encounter, during validation, what is called a <a
href="http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-02">JSON
Reference</a>. A JSON Reference is a JSON Object with one member named
<tt>$ref</tt>, and the value of this member is a text value which embodies a
URI. Implementations are required to follow JSON References until an actual
final content is reached (and this content may, or may not, be a valid JSON
Schema).</p>

<p>Now, more food for thought. Consider this schema:</p>

<pre>
    {
        "$ref": "some://where/else",
        "minimum": 3
    }
</pre>

<p>This is <b>still</b> a JSON Reference. Other schema keywords, such as
<tt>minimum</tt> in this example, should be <b>ignored</b>. And this is what
this implementation does.</p>

<p>Note that any failure in $ref validation is considered a fatal error.</p>

<h2>Schema syntax checking</h2>

<p>This is an equally important part of the validation process. One thing to
note about the previous step is that it will only check that JSON Reference
resolution ultimately leads to a JSON document, whatever that document is. Which
means it may not even be a JSON Object, therefore not a JSON Schema. This basic
check is done at that level.</p>

<p>The syntax validation process implies a <a href="org/eel/kitchen/jsonschema/syntax/SyntaxValidator.html" title="class in org.eel.kitchen.jsonschema.syntax"><code>SyntaxValidator</code></a> instance, which checks that
all keywords are syntactically correct using a series of <a href="org/eel/kitchen/jsonschema/syntax/SyntaxChecker.html" title="interface in org.eel.kitchen.jsonschema.syntax"><code>SyntaxChecker</code></a> objects.</p>

<p>The role of <a href="org/eel/kitchen/jsonschema/syntax/SyntaxChecker.html" title="interface in org.eel.kitchen.jsonschema.syntax"><code>SyntaxChecker</code></a> objects
in particular is very important: for a given keyword, a syntax checker ensures
that the value of this keyword is well formed. This is what allows the next step
in the process to be easier to implement.</p>

<h2>Instance (aka data) validation</h2>

<p>This is the part which actually matters to end users: ensure that their data
is valid.</p>

<p>The process begins with an instance of <code>InstanceValidator</code>. It will query, via the
factory, a set of <a href="org/eel/kitchen/jsonschema/keyword/KeywordValidator.html" title="class in org.eel.kitchen.jsonschema.keyword"><code>KeywordValidator</code></a>
instances. All of these keyword validators will then be called in turn to
validate the data.</p>

<h2>Object/array instance validation</h2>

<p>There is one more step to validation. The step above will only have validated
that the current "path" in the JSON instance will have been validated. However,
in the event where the instance is a so-called <i>container instance</i>, that
is it has children nodes, which is the case of objects and arrays, then a
further validation step is issued so that all children get validated.</p>

<p>The two classes responsible for this, <code>ArrayValidator</code> and <code>ObjectValidator</code>, take responsibility
from this point and will restart the validation process from scratch for each of
the instance children.</p>

<p>It should be noted that while array instance children only have to match
exactly one schema, object instance children may have to match several of them,
which does nothing to simplify matters...</p>

<h2>A particular note about <tt>type</tt>, <tt>disallow</tt>,
<tt>dependencies</tt> and <tt>extends</tt></h2>

<p>Those four schema keywords have the unfortunate property that they can
<i>also</i> restart the validation process from their own:</p>

<ul>
    <li><tt>type</tt> and <tt>disallow</tt> can bear schemas in their array
    representations; validation should consider those schemas;</li>
    <li>similarly, <tt>dependencies</tt> can link one property in an object
    instance to another schema, then the whole instance must also validate
    against that schema -- and you may have several occurrences of that;</li>
    <li><tt>extends</tt>, in a similar vein, unconditionally constrains the
    instance to obey the schema(s) it mentions.</li>
</ul>

<p>Those four schema keywords are an implementor's worst nightmare. Remember
that the validation process starts from <tt>$ref</tt> resolution: each of these
keywords, should they have schema dependencies of some sort, have to start the
whole validation process <i>from scratch</i>.</p></div>
</div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2012. All Rights Reserved.</small></p>
</body>
</html>
